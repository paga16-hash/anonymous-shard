
@startuml

interface TaskService {
  + getTasks(): Promise<Task[]>
  + getActiveTasks(): Promise<Task[]>
  + getPendingTasks(): Promise<Task[]>
  + getFailedTask(taskId: TaskId): Promise<Task>
  + pushTask(task: Task): void
  + interruptTask(taskId: TaskId): void
  + deleteTask(taskId: TaskId): void
}

TaskService --> TaskRepository : uses
TaskService --> TaskFactory : uses

interface TaskRepository {
  + saveResult(taskId: TaskId, result: string): void
}
note top of TaskRepository : Maybe to avoid? Depending on IPFS design choice

TaskRepository o-- Task

interface TaskFactory {
      + createTask(): Task
      + taskFrom(taskId: TaskId, otherTaskDetails: string): Task
}
TaskFactory -left-> Task : creates

interface Task {
    + getId(): TaskId
    + getStatus(): TaskStatus
    + getResult(): string
    + setResult(result: string): void
    + setStatus(status: TaskStatus): void
    + getDetails(): string
    + setDetails(details: string): void
    + getCreatedAt(): Date
    + setCreatedAt(date: Date): void
    + getUpdatedAt(): Date
    + setUpdatedAt(date: Date): void
}
note bottom of Task : Entity
Task o-left- TaskStatus

interface TaskStatus {
    + getStatus(): string
}
note left of TaskStatus : Value Object

enum StatusType {
  ACTIVE
  PENDING
  FAILED
}

StatusType -down- TaskStatus : has

interface TaskId {
    + getValue(): string
}

TaskId -down-> Task : identifies

@enduml
