"use strict";(self.webpackChunksite=self.webpackChunksite||[]).push([[8131],{7384:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>a,contentTitle:()=>i,default:()=>h,frontMatter:()=>o,metadata:()=>c,toc:()=>d});var r=t(4848),s=t(8453);const o={title:"Microservices patterns",position:2},i="Patterns",c={id:"report/design/architecture/patterns",title:"Microservices patterns",description:"Communication",source:"@site/docs/report/design/architecture/patterns.md",sourceDirName:"report/design/architecture",slug:"/report/design/architecture/patterns",permalink:"/anonymous-shard/docs/report/design/architecture/patterns",draft:!1,unlisted:!1,tags:[],version:"current",frontMatter:{title:"Microservices patterns",position:2},sidebar:"tutorialSidebar",previous:{title:"Documentation",permalink:"/anonymous-shard/docs/report/design/architecture/documentation"},next:{title:"Detailed Design",permalink:"/anonymous-shard/docs/report/design/detailed-design"}},a={},d=[{value:"Communication",id:"communication",level:2}];function u(e){const n={h1:"h1",h2:"h2",header:"header",li:"li",p:"p",strong:"strong",ul:"ul",...(0,s.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(n.header,{children:(0,r.jsx)(n.h1,{id:"patterns",children:"Patterns"})}),"\n",(0,r.jsx)(n.h2,{id:"communication",children:"Communication"}),"\n",(0,r.jsxs)(n.p,{children:["Several communication patterns are used in the system. When a user needs to communicate with their node (or peer) backend to exchange information, the ",(0,r.jsx)(n.strong,{children:"Remote Procedure Invocation"})," (request/response) pattern is used. This follows a ",(0,r.jsx)(n.strong,{children:"one-to-one"})," model. In contrast, the ",(0,r.jsx)(n.strong,{children:"Asynchronous Messaging"})," pattern (publish/subscribe) is employed when a peer needs to notify other components about an event, state change, or action."]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["For ",(0,r.jsx)(n.strong,{children:"RPC"}),", communication is implemented using the ",(0,r.jsx)(n.strong,{children:"REST"})," mechanism over the ",(0,r.jsx)(n.strong,{children:"HTTP"})," protocol."]}),"\n",(0,r.jsxs)(n.li,{children:["For ",(0,r.jsx)(n.strong,{children:"asynchronous messaging"}),", communication is event-driven."]}),"\n"]}),"\n",(0,r.jsxs)(n.p,{children:["All events and event brokers rely on ",(0,r.jsx)(n.strong,{children:"socket-based"})," mechanisms. The system can operate in either ",(0,r.jsx)(n.strong,{children:"anonymous"})," or ",(0,r.jsx)(n.strong,{children:"non-anonymous"})," mode, depending on the run configuration and user requirements. In ",(0,r.jsx)(n.strong,{children:"anonymous mode"}),", the system uses the ",(0,r.jsx)(n.strong,{children:"SOCKS5h proxy"})," to provide a secure communication channel over Tor."]}),"\n",(0,r.jsx)(n.p,{children:"For more technical details, refer to implementation-specific documentation."})]})}function h(e={}){const{wrapper:n}={...(0,s.R)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(u,{...e})}):u(e)}},8453:(e,n,t)=>{t.d(n,{R:()=>i,x:()=>c});var r=t(6540);const s={},o=r.createContext(s);function i(e){const n=r.useContext(o);return r.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function c(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:i(e.components),r.createElement(o.Provider,{value:n},e.children)}}}]);